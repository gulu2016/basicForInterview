### 计算机网络

1.Cookie和Session的区别，怎么防止Cookie欺骗 
  - [参考博客](https://blog.csdn.net/liyifan687/article/details/80077928)
  - Cookies是服务器在本地机器上存储的小段文本并随每一个请求发送至同一服务器，是在客户端保持状态的方案。
  - Session是存在服务器的一种用来存放用户数据的类HashTable结构。
  
2.从用户在浏览器输入域名，到浏览器显示出页面的过程 

3.osi七层模型与Tcp/ip五层模型
  ![osi七层模型与Tcp/ip五层模型](https://images2015.cnblogs.com/blog/705728/201604/705728-20160424234825491-384470376.png)

4.网络TCP UDP的区别
   - UDP无连接,速度较快，TCP有连接，速度较慢
   - UDP消耗带宽少，TCP消耗带宽大
   - UDP可靠性低，TCP可靠性高
   - UDP无序，TCP有序
5.TCP的三次握手，四次挥手；为什么不是二次握手；为什么需要四次挥手
   - 三次握手：(SYN是“请求连接”，ACK=1表示“收到了”，seq=x表示“我发送x”,ack=y表示“我想要y”)
		客户端->SYN=1,(ACK=0),seq=x
		服务器->SYN=1,ACK=1,seq=y,ack=x+1
		客户端->      ACK=1,seq=x+1,ack=y+1
   - 四次挥手：(FIN=1表示“分手吧”，ACK=1表示“收到了”，seq=x表示“我发送x”,ack=y表示“我想要y”)
		客户端->FIN=1,seq=x
		服务器->ACK=1,seq=y,ack=x+1
		（服务器数据传输结束后）
		服务器->FIN=1,ACK=1,seq=w,ack=x+1
		客户端->ACK=1,seq=x+1,ack=w+1
6.为什么连接的时候是三次握手，关闭的时候却是四次握手？
   - 建立连接时，服务端的应答和同步是一起发送的，
	 释放连接时，服务器收到FIN报文之后要传输完数据才能发送FIN报文，
	 所以先发送ACK，再发送FIN
	
7.为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？
   - Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，
     它必须确认Server接收到了该ACK。至于2MSL的长度，
     可以考虑客户端发送的ACK报文在到达服务器最后时刻失效（用了1MSL），服务器重新发送FIN报文，又用了1MSL
	
8.为什么不能用两次握手进行连接？
   - C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好,
     在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分组，
     只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁
	
9.如果已经建立了连接，但是客户端突然出现故障了怎么办？
   - TCP还设有一个保活计时器,发送多个探测报文没有响应之后，服务器就认为客户端出了故障，接着就关闭连接。
	